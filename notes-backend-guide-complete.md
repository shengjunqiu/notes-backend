# å…¨æ ˆç¬”è®°åº”ç”¨åç«¯å¼€å‘æŒ‡å—

## ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#é¡¹ç›®æ¦‚è¿°)
2. [æŠ€æœ¯æ ˆä»‹ç»](#æŠ€æœ¯æ ˆä»‹ç»)
3. [å¼€å‘ç¯å¢ƒè®¾ç½®](#å¼€å‘ç¯å¢ƒè®¾ç½®)
4. [é¡¹ç›®å¼€å‘æ­¥éª¤](#é¡¹ç›®å¼€å‘æ­¥éª¤)
   - [æ­¥éª¤1ï¼šåˆ›å»ºé¡¹ç›®å’Œè®¾ç½®ä¾èµ–](#æ­¥éª¤1åˆ›å»ºé¡¹ç›®å’Œè®¾ç½®ä¾èµ–)
   - [æ­¥éª¤2ï¼šè®¾ç½®æ•°æ®åº“å’ŒPrisma](#æ­¥éª¤2è®¾ç½®æ•°æ®åº“å’Œprisma)
   - [æ­¥éª¤3ï¼šè®¾ç½®GraphQLå’ŒæœåŠ¡å™¨](#æ­¥éª¤3è®¾ç½®graphqlå’ŒæœåŠ¡å™¨)
   - [æ­¥éª¤4ï¼šå®ç°è®¤è¯åŠŸèƒ½](#æ­¥éª¤4å®ç°è®¤è¯åŠŸèƒ½)
   - [æ­¥éª¤5ï¼šå®ç°ç¬”è®°åŠŸèƒ½](#æ­¥éª¤5å®ç°ç¬”è®°åŠŸèƒ½)
   - [æ­¥éª¤6ï¼šæ·»åŠ Redisç¼“å­˜](#æ­¥éª¤6æ·»åŠ redisç¼“å­˜)
   - [æ­¥éª¤7ï¼šé¡¹ç›®ç»“æ„ä¼˜åŒ–](#æ­¥éª¤7é¡¹ç›®ç»“æ„ä¼˜åŒ–)
5. [åç«¯å¼€å‘æ ¸å¿ƒçŸ¥è¯†ç‚¹](#åç«¯å¼€å‘æ ¸å¿ƒçŸ¥è¯†ç‚¹)
6. [æ‰©å±•å’Œä¸‹ä¸€æ­¥](#æ‰©å±•å’Œä¸‹ä¸€æ­¥)

## é¡¹ç›®æ¦‚è¿°

æœ¬æŒ‡å—å°†å¸®åŠ©å‰ç«¯å¼€å‘è€…æ„å»ºä¸€ä¸ªç°ä»£åŒ–çš„ç¬”è®°åº”ç”¨åç«¯ï¼Œä½œä¸ºå­¦ä¹ å…¨æ ˆå¼€å‘çš„ç¬¬ä¸€æ­¥ã€‚é¡¹ç›®åŠŸèƒ½åŒ…æ‹¬ç”¨æˆ·æ³¨å†Œã€ç™»å½•ã€åˆ›å»ºã€æŸ¥çœ‹ã€ä¿®æ”¹å’Œåˆ é™¤ç¬”è®°ã€‚

é€šè¿‡è¿™ä¸ªé¡¹ç›®ï¼Œä½ å°†å­¦ä¹ :
- ä½¿ç”¨TypeScriptå¼€å‘ç±»å‹å®‰å…¨çš„åç«¯åº”ç”¨
- ä½¿ç”¨Bunä½œä¸ºé«˜æ€§èƒ½JavaScript/TypeScriptè¿è¡Œæ—¶
- ä½¿ç”¨ElysiaJSæ„å»ºAPI
- å®ç°GraphQL APIè€Œéä¼ ç»ŸREST API
- ä½¿ç”¨Prismaæ“ä½œPostgreSQLæ•°æ®åº“
- å®ç°JWTè®¤è¯æœºåˆ¶
- ä½¿ç”¨Redisè¿›è¡Œç¼“å­˜ä¼˜åŒ–
- åº”ç”¨åç«¯æœ€ä½³å®è·µå’Œé¡¹ç›®ç»“æ„

## æŠ€æœ¯æ ˆä»‹ç»

### Bun
Bunæ˜¯ä¸€ä¸ªç°ä»£åŒ–çš„JavaScript/TypeScriptè¿è¡Œæ—¶ã€æ‰“åŒ…å·¥å…·å’ŒåŒ…ç®¡ç†å™¨ï¼Œç‰¹ç‚¹æ˜¯å¯åŠ¨é€Ÿåº¦å¿«ã€å†…å­˜å ç”¨ä½ã€‚å®ƒå…¼å®¹Node.js APIçš„åŒæ—¶æä¾›äº†æ›´å¥½çš„æ€§èƒ½ã€‚

### TypeScript
TypeScriptæ˜¯JavaScriptçš„è¶…é›†ï¼Œæ·»åŠ äº†é™æ€ç±»å‹å®šä¹‰ï¼Œæé«˜äº†ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§ï¼Œç‰¹åˆ«é€‚åˆå¤§å‹åº”ç”¨ç¨‹åºå¼€å‘ã€‚

### ElysiaJS
ElysiaJSæ˜¯ä¸ºBunä¼˜åŒ–çš„è½»é‡çº§webæ¡†æ¶ï¼Œç±»ä¼¼äºExpressæˆ–Fastifyï¼Œä½†æ€§èƒ½æ›´å¥½ï¼Œå¯¹TypeScriptçš„æ”¯æŒæ›´å¥½ã€‚

### PostgreSQL
PostgreSQLæ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„å¼€æºå…³ç³»å‹æ•°æ®åº“ç³»ç»Ÿï¼Œå…·æœ‰å¼ºå¤§çš„æ•°æ®å®Œæ•´æ€§ã€æ‰©å±•æ€§å’Œå¯¹å¤æ‚æŸ¥è¯¢çš„æ”¯æŒã€‚

### Prisma
Prismaæ˜¯ä¸€ä¸ªç°ä»£ORMï¼ˆå¯¹è±¡å…³ç³»æ˜ å°„ï¼‰å·¥å…·ï¼Œå®ƒæä¾›ç±»å‹å®‰å…¨çš„æ•°æ®åº“è®¿é—®ï¼Œè‡ªåŠ¨ç”ŸæˆåŸºäºæ•°æ®åº“æ¨¡å¼çš„TypeScriptç±»å‹ã€‚

### GraphQL
GraphQLæ˜¯ä¸€ç§APIæŸ¥è¯¢è¯­è¨€å’Œè¿è¡Œæ—¶ï¼Œå…è®¸å®¢æˆ·ç«¯ç²¾ç¡®æŒ‡å®šæ‰€éœ€çš„æ•°æ®ï¼Œå‡å°‘è¿‡åº¦è·å–å’Œå¤šæ¬¡APIè°ƒç”¨çš„é—®é¢˜ã€‚

### jsonwebtoken
ç”¨äºç”Ÿæˆå’ŒéªŒè¯JSON Web Tokens (JWT)ï¼Œå®ç°ç”¨æˆ·è®¤è¯å’Œæˆæƒã€‚

### Redis
Redisæ˜¯ä¸€ä¸ªå†…å­˜æ•°æ®ç»“æ„å­˜å‚¨ï¼Œå¯ç”¨ä½œæ•°æ®åº“ã€ç¼“å­˜å’Œæ¶ˆæ¯ä»£ç†ï¼Œæˆ‘ä»¬åœ¨é¡¹ç›®ä¸­ç”¨å®ƒæ¥ç¼“å­˜ç”¨æˆ·æ•°æ®ã€‚

## å¼€å‘ç¯å¢ƒè®¾ç½®

åœ¨å¼€å§‹ä¹‹å‰ï¼Œç¡®ä¿ä½ å·²ç»å®‰è£…äº†ä»¥ä¸‹å·¥å…·:

1. **Bun**: è®¿é—® [bun.sh](https://bun.sh) è·å–å®‰è£…è¯´æ˜
2. **PostgreSQL**: å®‰è£…å¹¶å¯åŠ¨PostgreSQLæœåŠ¡
3. **Redis**: å®‰è£…å¹¶å¯åŠ¨RedisæœåŠ¡
4. **ä»£ç ç¼–è¾‘å™¨**: æ¨èä½¿ç”¨Visual Studio Codeï¼Œå®ƒå¯¹TypeScriptæœ‰å¾ˆå¥½çš„æ”¯æŒ

## é¡¹ç›®å¼€å‘æ­¥éª¤

### æ­¥éª¤1ï¼šåˆ›å»ºé¡¹ç›®å’Œè®¾ç½®ä¾èµ–

1. ä½¿ç”¨Elysiaæ¨¡æ¿åˆ›å»ºæ–°é¡¹ç›®:
```bash
bun create elysia notes-backend
cd notes-backend
```

2. å®‰è£…å¿…è¦çš„ä¾èµ–:
```bash
bun add @elysiajs/graphql-yoga graphql @graphql-tools/schema
bun add jsonwebtoken bcryptjs
bun add @prisma/client
bun add ioredis
bun add prisma --dev
bun add @types/jsonwebtoken @types/bcryptjs --dev
```

**çŸ¥è¯†ç‚¹**:
- `bun create` å‘½ä»¤ç”¨äºåˆ›å»ºæ–°é¡¹ç›®
- ä½¿ç”¨ `bun add` å®‰è£…ä¾èµ–ï¼Œç±»ä¼¼äº `npm install`
- `--dev` æ ‡å¿—è¡¨ç¤ºå¼€å‘ä¾èµ–ï¼Œåªåœ¨å¼€å‘ç¯å¢ƒä¸­ä½¿ç”¨
- Bunçš„åŒ…ç®¡ç†åŠŸèƒ½ç±»ä¼¼äºnpm/yarnï¼Œä½†é€Ÿåº¦æ›´å¿«
- ElysiaJSä¸“ä¸ºBunä¼˜åŒ–ï¼Œæä¾›ç±»ä¼¼Expressä½†æ›´é«˜æ€§èƒ½çš„æ¡†æ¶
- GraphQL Yogaæ˜¯ä¸€ä¸ªåŠŸèƒ½é½å…¨çš„GraphQLæœåŠ¡å™¨

### æ­¥éª¤2ï¼šè®¾ç½®æ•°æ®åº“å’ŒPrisma

1. åˆå§‹åŒ–Prisma:
```bash
bunx prisma init
```

2. é…ç½®æ•°æ®åº“è¿æ¥(åœ¨ `.env` æ–‡ä»¶ä¸­):
```
DATABASE_URL="postgresql://username:password@localhost:5432/notes_db?schema=public"
```

3. å®šä¹‰æ•°æ®æ¨¡å‹ (åœ¨ `prisma/schema.prisma` æ–‡ä»¶ä¸­):
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  notes     Note[]
}

model Note {
  id        Int      @id @default(autoincrement())
  title     String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

4. åˆ›å»ºæ•°æ®åº“è¿ç§»å¹¶ç”ŸæˆPrismaå®¢æˆ·ç«¯:
```bash
bunx prisma migrate dev --name init
```

**çŸ¥è¯†ç‚¹**:
- Prismaä½¿ç”¨å£°æ˜å¼æ•°æ®å»ºæ¨¡è¯­è¨€å®šä¹‰æ•°æ®åº“ç»“æ„
- `@id`, `@default`, `@unique` ç­‰æ˜¯Prismaæ¨¡å‹å±æ€§è£…é¥°å™¨
- `@relation` å®šä¹‰æ¨¡å‹ä¹‹é—´çš„å…³ç³»
- `@default(now())` è®¾ç½®å­—æ®µé»˜è®¤å€¼ä¸ºå½“å‰æ—¶é—´æˆ³
- `@updatedAt` è‡ªåŠ¨åœ¨è®°å½•æ›´æ–°æ—¶æ›´æ–°æ—¶é—´æˆ³
- `migrate dev` åˆ›å»ºå’Œåº”ç”¨æ•°æ®åº“è¿ç§»
- ä¸€å¯¹å¤šå…³ç³»: ä¸€ä¸ªç”¨æˆ·å¯ä»¥æœ‰å¤šä¸ªç¬”è®°
- `onDelete: Cascade` è¡¨ç¤ºå½“åˆ é™¤ç”¨æˆ·æ—¶è‡ªåŠ¨åˆ é™¤å…¶æ‰€æœ‰ç¬”è®°
- Prismaä¼šæ ¹æ®æ¨¡å‹è‡ªåŠ¨ç”ŸæˆTypeScriptç±»å‹å®šä¹‰

### æ­¥éª¤3ï¼šè®¾ç½®GraphQLå’ŒæœåŠ¡å™¨

1. åˆ›å»ºPrismaå®¢æˆ·ç«¯å®ä¾‹ (åœ¨ `src/lib/prisma.ts` æ–‡ä»¶ä¸­):
```typescript
import { PrismaClient } from '@prisma/client'

export const prisma = new PrismaClient()
```

2. åˆ›å»ºç±»å‹å®šä¹‰æ–‡ä»¶ (åœ¨ `src/types/index.ts` æ–‡ä»¶ä¸­):
```typescript
import { User } from '@prisma/client';

export interface Context {
  user: User | null;
  sign: (payload: any) => string;
}

export interface AuthPayload {
  token: string;
  user: User;
}

export interface BearerPayload {
  userId: number;
}
```

3. åˆ›å»ºé…ç½®æ–‡ä»¶ (åœ¨ `src/config.ts` æ–‡ä»¶ä¸­):
```typescript
export const config = {
  jwt: {
    secret: process.env.JWT_SECRET || 'your-secret-key',
    expiresIn: '7d',
  },
  server: {
    port: parseInt(process.env.PORT || '3000'),
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
  },
  db: {
    url: process.env.DATABASE_URL,
  }
};
```

4. åˆ†ç¦»GraphQLç±»å‹å®šä¹‰åˆ°ç‹¬ç«‹æ–‡ä»¶:

`src/schema/user.ts`:
```typescript
export const userTypeDefs = `
  type User {
    id: Int!
    email: String!
    notes: [Note!]!
  }

  extend type Query {
    me: User
  }
`;
```

`src/schema/note.ts`:
```typescript
export const noteTypeDefs = `
  type Note {
    id: Int!
    title: String!
    content: String!
    createdAt: String!
    updatedAt: String!
    user: User!
  }

  extend type Query {
    notes: [Note!]!
    note(id: Int!): Note
  }

  extend type Mutation {
    createNote(title: String!, content: String!): Note!
    updateNote(id: Int!, title: String, content: String): Note!
    deleteNote(id: Int!): Note!
  }
`;
```

`src/schema/auth.ts`:
```typescript
export const authTypeDefs = `
  type AuthPayload {
    token: String!
    user: User!
  }

  type Mutation {
    register(email: String!, password: String!): AuthPayload!
    login(email: String!, password: String!): AuthPayload!
  }

  type Query {
    _empty: String
  }
`;
```

`src/schema/index.ts`:
```typescript
import { userTypeDefs } from './user';
import { noteTypeDefs } from './note';
import { authTypeDefs } from './auth';

export const typeDefs = `
  ${authTypeDefs}
  ${userTypeDefs}
  ${noteTypeDefs}
`;
```

**çŸ¥è¯†ç‚¹**:
- GraphQLä½¿ç”¨ç±»å‹å®šä¹‰è¯­è¨€(SDL)å®šä¹‰APIçš„ç»“æ„
- `!` è¡¨ç¤ºéç©ºå­—æ®µ
- `[]` è¡¨ç¤ºæ•°ç»„
- `extend type Query` å…è®¸åœ¨å¤šä¸ªæ–‡ä»¶ä¸­æ‰©å±•ç›¸åŒçš„ç±»å‹
- GraphQLä¸­çš„å¯¹è±¡å…³ç³»å¯ä»¥é€šè¿‡è§£æå™¨å‡½æ•°å®ç°
- ç±»å‹å®šä¹‰æ–‡ä»¶å®šä¹‰äº†APIçš„"å¥‘çº¦"ï¼Œè®©å‰åç«¯å¼€å‘è€…æ˜ç¡®äº†è§£æ¥å£è§„èŒƒ
- GraphQLæœ‰ä¸¤ç§ä¸»è¦æ“ä½œç±»å‹ï¼šQueryï¼ˆæŸ¥è¯¢ï¼‰å’ŒMutationï¼ˆä¿®æ”¹ï¼‰
- å•ä¸€ç«¯ç‚¹ï¼šGraphQLé€šè¿‡å•ä¸€URLæä¾›æ‰€æœ‰APIåŠŸèƒ½ï¼Œä¸åŒäºRESTçš„å¤šç«¯ç‚¹æ–¹å¼
- å®¢æˆ·ç«¯å¯ä»¥ç²¾ç¡®æŒ‡å®šéœ€è¦çš„å­—æ®µï¼Œé¿å…è¿‡åº¦è·å–

### æ­¥éª¤4ï¼šå®ç°è®¤è¯åŠŸèƒ½

1. åˆ›å»ºèº«ä»½éªŒè¯è§£æå™¨ (åœ¨ `src/resolvers/auth.ts` æ–‡ä»¶ä¸­):
```typescript
import { prisma } from '../lib/prisma';
import bcrypt from 'bcryptjs';
import { User } from '@prisma/client';
import { Context, AuthPayload, BearerPayload } from '../types';
import { cacheService } from '../services/cache';
import { DuplicateError, ValidationError } from '../utils/errors';
import { createLogger } from '../services/logger';

const logger = createLogger('AuthResolver');

export const authResolvers = {
  Mutation: {
    register: async (
      _: any, 
      { email, password }: { email: string; password: string }, 
      { sign }: Context
    ): Promise<AuthPayload> => {
      try {
        // éªŒè¯å¯†ç å¼ºåº¦
        if (password.length < 8) {
          throw new ValidationError('Password must be at least 8 characters long');
        }
        
        // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²è¢«æ³¨å†Œ
        const existingUser = await prisma.user.findUnique({
          where: { email },
        });
        
        if (existingUser) {
          throw new DuplicateError('User', 'email', email);
        }
        
        // åŠ å¯†å¯†ç 
        const hashedPassword = await bcrypt.hash(password, 10);
        
        // åˆ›å»ºç”¨æˆ·
        const user = await prisma.user.create({
          data: {
            email,
            password: hashedPassword,
          },
        });
        
        logger.info(`User registered: ${user.id}`);
        
        // ç¼“å­˜ç”¨æˆ·æ•°æ®
        await cacheService.setUserCache(user);
        
        // ç”ŸæˆJWTä»¤ç‰Œ
        const token = sign({ userId: user.id } as BearerPayload);
        
        return { token, user };
      } catch (error) {
        if (error instanceof ValidationError || error instanceof DuplicateError) {
          // è¿™äº›æ˜¯å·²çŸ¥çš„ä¸šåŠ¡é€»è¾‘é”™è¯¯ï¼Œç›´æ¥æŠ›å‡º
          throw error;
        }
        
        // è®°å½•æ„å¤–é”™è¯¯
        logger.error('Registration failed', error as Error, { email });
        throw new Error('Registration failed. Please try again later.');
      }
    },
    
    login: async (
      _: any, 
      { email, password }: { email: string; password: string }, 
      { sign }: Context
    ): Promise<AuthPayload> => {
      try {
        // æŸ¥æ‰¾ç”¨æˆ·
        const user = await prisma.user.findUnique({
          where: { email },
        });
        
        if (!user) {
          throw new Error('Invalid email or password');
        }
        
        // éªŒè¯å¯†ç 
        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
          throw new Error('Invalid email or password');
        }
        
        logger.info(`User logged in: ${user.id}`);
        
        // æ›´æ–°/è®¾ç½®ç”¨æˆ·ç¼“å­˜
        await cacheService.setUserCache(user);
        
        // ç”ŸæˆJWTä»¤ç‰Œ
        const token = sign({ userId: user.id } as BearerPayload);
        
        return { token, user };
      } catch (error) {
        // è®°å½•ç™»å½•å¤±è´¥ï¼Œä½†ä¸æ³„éœ²å…·ä½“åŸå› 
        logger.warn('Login failed', { email, error: (error as Error).message });
        
        // ä¸ºäº†å®‰å…¨ï¼Œä¸è¦æ³„éœ²æ˜¯é‚®ç®±è¿˜æ˜¯å¯†ç é”™è¯¯
        throw new Error('Invalid email or password');
      }
    },
  },
};
```

2. åˆ›å»ºè‡ªå®šä¹‰é”™è¯¯ç±» (åœ¨ `src/utils/errors.ts` æ–‡ä»¶ä¸­):
```typescript
export class AuthenticationError extends Error {
  constructor(message = 'Authentication required') {
    super(message);
    this.name = 'AuthenticationError';
  }
}

export class NotFoundError extends Error {
  constructor(entity = 'Resource', id?: number | string) {
    const message = id ? `${entity} with ID ${id} not found` : `${entity} not found`;
    super(message);
    this.name = 'NotFoundError';
  }
}

export class ValidationError extends Error {
  constructor(message = 'Validation failed') {
    super(message);
    this.name = 'ValidationError';
  }
}

export class DuplicateError extends Error {
  constructor(entity = 'Resource', field?: string, value?: string) {
    const message = field && value 
      ? `${entity} with ${field} ${value} already exists` 
      : `${entity} already exists`;
    super(message);
    this.name = 'DuplicateError';
  }
}
```

**çŸ¥è¯†ç‚¹**:
- bcryptç”¨äºå®‰å…¨åœ°å“ˆå¸Œå¯†ç ï¼Œé˜²æ­¢æ˜æ–‡å­˜å‚¨
- å¯†ç åŠ ç›ï¼šbcryptè‡ªåŠ¨ä¸ºæ¯ä¸ªå¯†ç æ·»åŠ ä¸åŒçš„"ç›"ï¼Œé˜²æ­¢å½©è™¹è¡¨æ”»å‡»
- JWT (JSON Web Tokens)ç”¨äºæ— çŠ¶æ€èº«ä»½éªŒè¯
- é”™è¯¯å¤„ç†æœ€ä½³å®è·µ: ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ç±»ï¼Œæä¾›æ›´å…·æè¿°æ€§çš„é”™è¯¯æ¶ˆæ¯
- å®‰å…¨æœ€ä½³å®è·µ: ä¸æ³„éœ²å…·ä½“çš„è®¤è¯é”™è¯¯ä¿¡æ¯ï¼Œé¿å…æšä¸¾æ”»å‡»
- å¯†ç éªŒè¯è¿‡ç¨‹: å“ˆå¸Œæ¯”è¾ƒè€Œéæ˜æ–‡æ¯”è¾ƒ
- try/catch é”™è¯¯å¤„ç†ï¼šæ•è·å¹¶é€‚å½“å¤„ç†å¼‚å¸¸
- é”™è¯¯åˆ†ç±»ï¼šåŒºåˆ†ç”¨æˆ·è¾“å…¥é”™è¯¯å’Œç³»ç»Ÿé”™è¯¯
- æ—¥å¿—è®°å½•ï¼šè®°å½•é‡è¦äº‹ä»¶å’Œé”™è¯¯ï¼Œæœ‰åŠ©äºé—®é¢˜æ’æŸ¥
- å¯¹å¤–é”™è¯¯ä¿¡æ¯æ¨¡ç³ŠåŒ–ï¼šä¸å‘ç”¨æˆ·é€éœ²å…·ä½“çš„é”™è¯¯åŸå› ï¼Œå¢å¼ºå®‰å…¨æ€§

### æ­¥éª¤5ï¼šå®ç°ç¬”è®°åŠŸèƒ½

1. åˆ›å»ºç¬”è®°è§£æå™¨ (åœ¨ `src/resolvers/note.ts` æ–‡ä»¶ä¸­):
```typescript
import { prisma } from '../lib/prisma';
import { User, Note } from '@prisma/client';
import { Context } from '../types';
import { AuthenticationError, NotFoundError } from '../utils/errors';
import { createLogger } from '../services/logger';

const logger = createLogger('NoteResolver');

export const noteResolvers = {
  Query: {
    notes: async (_: any, __: any, { user }: Context): Promise<Note[]> => {
      if (!user) throw new AuthenticationError();
      
      return prisma.note.findMany({
        where: { userId: user.id },
        orderBy: { updatedAt: 'desc' },
      });
    },
    
    note: async (_: any, { id }: { id: number }, { user }: Context): Promise<Note | null> => {
      if (!user) throw new AuthenticationError();
      
      const note = await prisma.note.findFirst({
        where: { id, userId: user.id },
      });
      
      if (!note) throw new NotFoundError('Note', id);
      
      return note;
    },
  },
  
  Mutation: {
    createNote: async (
      _: any, 
      { title, content }: { title: string; content: string }, 
      { user }: Context
    ): Promise<Note> => {
      if (!user) throw new AuthenticationError();
      
      try {
        const note = await prisma.note.create({
          data: {
            title,
            content,
            userId: user.id,
          },
        });
        
        logger.info(`Note created: ${note.id}`, { userId: user.id });
        
        return note;
      } catch (error) {
        logger.error('Error creating note', error as Error, { userId: user.id });
        throw new Error('Failed to create note. Please try again.');
      }
    },
    
    updateNote: async (
      _: any, 
      { id, title, content }: { id: number; title?: string; content?: string }, 
      { user }: Context
    ): Promise<Note> => {
      if (!user) throw new AuthenticationError();
      
      // ç¡®ä¿ç¬”è®°å±äºå½“å‰ç”¨æˆ·
      const note = await prisma.note.findFirst({
        where: { id, userId: user.id },
      });
      
      if (!note) throw new NotFoundError('Note', id);
      
      try {
        const updatedNote = await prisma.note.update({
          where: { id },
          data: {
            ...(title && { title }),
            ...(content && { content }),
          },
        });
        
        logger.info(`Note updated: ${id}`, { userId: user.id });
        
        return updatedNote;
      } catch (error) {
        logger.error('Error updating note', error as Error, { noteId: id, userId: user.id });
        throw new Error('Failed to update note. Please try again.');
      }
    },
    
    deleteNote: async (
      _: any, 
      { id }: { id: number }, 
      { user }: Context
    ): Promise<Note> => {
      if (!user) throw new AuthenticationError();
      
      // ç¡®ä¿ç¬”è®°å±äºå½“å‰ç”¨æˆ·
      const note = await prisma.note.findFirst({
        where: { id, userId: user.id },
      });
      
      if (!note) throw new NotFoundError('Note', id);
      
      try {
        const deletedNote = await prisma.note.delete({
          where: { id },
        });
        
        logger.info(`Note deleted: ${id}`, { userId: user.id });
        
        return deletedNote;
      } catch (error) {
        logger.error('Error deleting note', error as Error, { noteId: id, userId: user.id });
        throw new Error('Failed to delete note. Please try again.');
      }
    },
  },
  
  Note: {
    user: (parent: Note): Promise<User | null> => {
      return prisma.user.findUnique({
        where: { id: parent.userId },
      });
    },
  },
};
```

2. åˆ›å»ºç”¨æˆ·è§£æå™¨ (åœ¨ `src/resolvers/user.ts` æ–‡ä»¶ä¸­):
```typescript
import { prisma } from '../lib/prisma';
import { User, Note } from '@prisma/client';
import { Context } from '../types';
import { AuthenticationError } from '../utils/errors';

export const userResolvers = {
  Query: {
    me: async (_: any, __: any, { user }: Context): Promise<User | null> => {
      if (!user) throw new AuthenticationError();
      return user;
    },
  },
  
  User: {
    notes: (parent: User): Promise<Note[]> => {
      return prisma.note.findMany({
        where: { userId: parent.id },
        orderBy: { updatedAt: 'desc' },
      });
    },
  },
};
```

3. åˆå¹¶è§£æå™¨ (åœ¨ `src/resolvers/index.ts` æ–‡ä»¶ä¸­):
```typescript
import { userResolvers } from './user';
import { noteResolvers } from './note';
import { authResolvers } from './auth';

// åˆå¹¶æ‰€æœ‰è§£æå™¨
export const resolvers = {
  Query: {
    ...userResolvers.Query,
    ...noteResolvers.Query,
  },
  Mutation: {
    ...authResolvers.Mutation,
    ...noteResolvers.Mutation,
  },
  User: userResolvers.User,
  Note: noteResolvers.Note,
};
```

**çŸ¥è¯†ç‚¹**:
- GraphQLè§£æå™¨ç»“æ„ï¼šè§£æå™¨å‡½æ•°æ¥æ”¶å››ä¸ªå‚æ•°(parent, args, context, info)
- Contextå¯¹è±¡ç”¨äºåœ¨è§£æå™¨é—´å…±äº«æ•°æ®ï¼Œå¦‚å½“å‰è®¤è¯ç”¨æˆ·
- è§£æå™¨å‚æ•°ï¼šparentæ˜¯çˆ¶å­—æ®µçš„è§£æç»“æœï¼ŒargsåŒ…å«GraphQLæŸ¥è¯¢çš„å‚æ•°
- è®¿é—®æ§åˆ¶ï¼šéªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™æ“ä½œèµ„æº
- æ•°æ®å…³ç³»è§£æï¼šé€šè¿‡å…³ç³»å­—æ®µè§£æå™¨ï¼ˆå¦‚User.notesï¼‰å¡«å……ç›¸å…³æ•°æ®
- å¯é€‰æ›´æ–°ï¼šä½¿ç”¨è§£æ„èµ‹å€¼å’Œæ¡ä»¶å±æ€§åªæ›´æ–°æä¾›çš„å­—æ®µ
- æ’åºï¼šä½¿ç”¨orderByæŒ‡å®šç»“æœæ’åºæ–¹å¼
- é”™è¯¯å¤„ç†ï¼šåŒºåˆ†ä¸åŒç±»å‹çš„é”™è¯¯å¹¶é€‚å½“å“åº”
- æ—¥å¿—è®°å½•ï¼šè®°å½•å…³é”®æ“ä½œä»¥ä¾¿å®¡è®¡å’Œè°ƒè¯•
- èµ„æºæ‰€æœ‰æƒéªŒè¯ï¼šç¡®ä¿ç”¨æˆ·åªèƒ½æ“ä½œè‡ªå·±çš„èµ„æº

### æ­¥éª¤6ï¼šæ·»åŠ Redisç¼“å­˜

1. åˆ›å»ºRediså®¢æˆ·ç«¯ (åœ¨ `src/lib/redis.ts` æ–‡ä»¶ä¸­):
```typescript
import Redis from 'ioredis';
import { config } from '../config';

// åˆ›å»ºRediså®¢æˆ·ç«¯
export const redis = new Redis({
  host: config.redis.host,
  port: config.redis.port,
});

// å¤„ç†è¿æ¥é”™è¯¯
redis.on('error', (err) => {
  console.error('Redis connection error:', err);
});

// å¤„ç†è¿æ¥æˆåŠŸ
redis.on('connect', () => {
  console.log('Redis connected successfully');
});
```

2. åˆ›å»ºç¼“å­˜æœåŠ¡ (åœ¨ `src/services/cache.ts` æ–‡ä»¶ä¸­):
```typescript
import { redis } from '../lib/redis';
import { User } from '@prisma/client';

export const cacheService = {
  // è®¾ç½®ç”¨æˆ·ç¼“å­˜
  setUserCache: async (user: User): Promise<void> => {
    await redis.set(
      `user:${user.id}`,
      JSON.stringify(user),
      'EX',
      3600
    );
  },
  
  // è·å–ç”¨æˆ·ç¼“å­˜
  getUserCache: async (userId: number): Promise<User | null> => {
    const cachedUser = await redis.get(`user:${userId}`);
    if (cachedUser) {
      return JSON.parse(cachedUser);
    }
    return null;
  },
  
  // æ¸…é™¤ç”¨æˆ·ç¼“å­˜
  clearUserCache: async (userId: number): Promise<void> => {
    await redis.del(`user:${userId}`);
  },
  
  // æ¸…é™¤ç”¨æˆ·ç›¸å…³çš„æ‰€æœ‰ç¼“å­˜
  clearAllUserCache: async (userId: number): Promise<void> => {
    // æ¸…é™¤ç”¨æˆ·ç¼“å­˜
    await redis.del(`user:${userId}`);
    
    // å¦‚æœæœ‰å…¶ä»–ä¸ç”¨æˆ·ç›¸å…³çš„ç¼“å­˜ï¼Œä¹Ÿå¯ä»¥åœ¨è¿™é‡Œæ¸…é™¤
    // ä¾‹å¦‚ï¼Œç”¨æˆ·çš„ç¬”è®°åˆ—è¡¨ç¼“å­˜
    await redis.del(`user:${userId}:notes`);
  }
};
```

3. åˆ›å»ºæ—¥å¿—æœåŠ¡ (åœ¨ `src/services/logger.ts` æ–‡ä»¶ä¸­):
```typescript
enum LogLevel {
  DEBUG = 'DEBUG',
  INFO = 'INFO',
  WARN = 'WARN',
  ERROR = 'ERROR',
}

class Logger {
  private context: string;

  constructor(context: string) {
    this.context = context;
  }

  private log(level: LogLevel, message: string, meta?: any): void {
    const timestamp = new Date().toISOString();
    const logData = {
      timestamp,
      level,
      context: this.context,
      message,
      ...(meta && { meta }),
    };
    
    // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œä½ å¯èƒ½æƒ³å°†æ—¥å¿—å†™å…¥æ–‡ä»¶æˆ–å‘é€åˆ°æ—¥å¿—æœåŠ¡
    console.log(JSON.stringify(logData));
  }

  debug(message: string, meta?: any): void {
    this.log(LogLevel.DEBUG, message, meta);
  }

  info(message: string, meta?: any): void {
    this.log(LogLevel.INFO, message, meta);
  }

  warn(message: string, meta?: any): void {
    this.log(LogLevel.WARN, message, meta);
  }

  error(message: string, error?: Error, meta?: any): void {
    const errorMeta = error ? {
      name: error.name,
      message: error.message,
      stack: error.stack,
      ...meta,
    } : meta;
    
    this.log(LogLevel.ERROR, message, errorMeta);
  }
}

export const createLogger = (context: string): Logger => {
  return new Logger(context);
};
```

**çŸ¥è¯†ç‚¹**:
- Redisä½œä¸ºé«˜æ€§èƒ½å†…å­˜æ•°æ®å­˜å‚¨ï¼Œé€‚åˆç¼“å­˜åœºæ™¯
- ç¼“å­˜ç­–ç•¥: è¯»å–æ—¶å…ˆæŸ¥ç¼“å­˜ï¼Œç¼ºå¤±æ—¶æŸ¥æ•°æ®åº“å¹¶æ›´æ–°ç¼“å­˜
- ç¼“å­˜è¿‡æœŸ: ä½¿ç”¨'EX'å‚æ•°è®¾ç½®é”®çš„è¿‡æœŸæ—¶é—´ï¼Œé˜²æ­¢ç¼“å­˜è¿‡æ—¶
- ç¼“å­˜é”®è®¾è®¡: ä½¿ç”¨å‘½åç©ºé—´ï¼ˆå¦‚'user:'å‰ç¼€ï¼‰ç»„ç»‡ç¼“å­˜é”®
- æœåŠ¡æ¨¡å¼: ä½¿ç”¨æœåŠ¡å¯¹è±¡å°è£…ç›¸å…³åŠŸèƒ½ï¼Œæé«˜ä»£ç å¯ç»´æŠ¤æ€§
- é”™è¯¯å¤„ç†: ç›‘å¬Redisè¿æ¥é”™è¯¯ï¼Œæé«˜ç³»ç»Ÿé²æ£’æ€§
- ç»“æ„åŒ–æ—¥å¿—: åŒ…å«æ—¶é—´æˆ³ã€çº§åˆ«ã€ä¸Šä¸‹æ–‡å’Œå…ƒæ•°æ®çš„ç»“æ„åŒ–æ—¥å¿—
- æ—¥å¿—çº§åˆ«: ä¸åŒä¸¥é‡ç¨‹åº¦çš„æ—¥å¿—ä½¿ç”¨ä¸åŒçº§åˆ«
- JSONåºåˆ—åŒ–: ç¼“å­˜å¯¹è±¡æ—¶è¿›è¡Œåºåˆ—åŒ–å’Œååºåˆ—åŒ–
- ç¼“å­˜ä¸€è‡´æ€§: å½“æ•°æ®æ›´æ”¹æ—¶æ¸…é™¤ç›¸å…³ç¼“å­˜

### æ­¥éª¤7ï¼šé¡¹ç›®ç»“æ„ä¼˜åŒ–

1. æ›´æ–°ä¸»åº”ç”¨æ–‡ä»¶ (åœ¨ `src/index.ts` æ–‡ä»¶ä¸­):
```typescript
import { Elysia } from 'elysia';
import { yoga } from '@elysiajs/graphql-yoga';
import jwt, { Secret } from 'jsonwebtoken';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { typeDefs } from './schema';
import { resolvers } from './resolvers';
import { prisma } from './lib/prisma';
import { Context, BearerPayload } from './types';
import { config } from './config';
import { createLogger } from './services/logger';
import { cacheService } from './services/cache';

const logger = createLogger('App');

// åˆ›å»ºGraphQL Schema
const schema = makeExecutableSchema({
  typeDefs,
  resolvers,
});

// æ˜ç¡®å®šä¹‰JWTå¯†é’¥ï¼Œç¡®ä¿ç±»å‹æ­£ç¡®
const jwtSecret: Secret = config.jwt.secret;

const app = new Elysia()
  .get('/health', () => {
    return {
      status: 'ok',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
    };
  })
  .use(
    yoga({
      schema,
      context: async ({ request }): Promise<Context> => {
        // è·å–æˆæƒå¤´
        const authHeader = request.headers.get('authorization');
        let user = null;
        
        if (authHeader && authHeader.startsWith('Bearer ')) {
          const token = authHeader.split(' ')[1];
          try {
            // éªŒè¯JWTä»¤ç‰Œ
            const decoded = jwt.verify(token, jwtSecret) as BearerPayload;
            
            if (decoded && decoded.userId) {
              // å…ˆå°è¯•ä»Redisè·å–ç”¨æˆ·
              user = await cacheService.getUserCache(decoded.userId);
              
              if (!user) {
                // ä»æ•°æ®åº“è·å–å¹¶ç¼“å­˜
                user = await prisma.user.findUnique({
                  where: { id: decoded.userId },
                });
                
                if (user) {
                  // ç¼“å­˜ç”¨æˆ·æ•°æ®
                  await cacheService.setUserCache(user);
                }
              }
            }
          } catch (error) {
            // æ— æ•ˆä»¤ç‰Œï¼Œç”¨æˆ·ä¿æŒä¸ºnull
            logger.error('Token verification error', error as Error);
          }
        }
        
        return { 
          user,
          sign: (payload: any) => {
            return jwt.sign(payload, jwtSecret, { 
              expiresIn: '7d'
            });
          }
        };
      },
    })
  )
  .listen(config.server.port);

logger.info(`ğŸ¦Š GraphQL API is running at http://${app.server?.hostname}:${app.server?.port}/graphql`);
```

2. åˆ›å»ºç¯å¢ƒå˜é‡ç¤ºä¾‹æ–‡ä»¶ (`.env.example`):
```
DATABASE_URL="postgresql://username:password@localhost:5432/notes_db?schema=public"
JWT_SECRET="your-secret-key"
REDIS_HOST="localhost"
REDIS_PORT="6379"
PORT="3000"
```

**çŸ¥è¯†ç‚¹**:
- æ¨¡å—åŒ–è®¾è®¡æœ‰åŠ©äºä»£ç çš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§
- ä½¿ç”¨ç¯å¢ƒå˜é‡è¿›è¡Œé…ç½®ï¼Œé¿å…ç¡¬ç¼–ç æ•æ„Ÿä¿¡æ¯
- æ·»åŠ å¥åº·æ£€æŸ¥ç«¯ç‚¹å¯¹ç³»ç»Ÿç›‘æ§è‡³å…³é‡è¦
- ä½¿ç”¨æ—¥å¿—è®°å½•é‡è¦äº‹ä»¶å’Œé”™è¯¯ï¼Œä¾¿äºæ•…éšœæ’æŸ¥
- é¡¹ç›®ç»“æ„åº”æŒ‰åŠŸèƒ½è€ŒéæŠ€æœ¯è§’è‰²ç»„ç»‡
- GraphQLä¸Šä¸‹æ–‡å‡½æ•°ä¸­å¤„ç†èº«ä»½éªŒè¯é€»è¾‘
- JWTéªŒè¯ï¼šè§£æAuthorizationå¤´å¹¶éªŒè¯ä»¤ç‰Œæœ‰æ•ˆæ€§
- é›†ä¸­å¼é…ç½®ç®¡ç†ä½¿é…ç½®æ›´æ˜“äºç»´æŠ¤
- TypeScriptç±»å‹æ–­è¨€ç¡®ä¿ç±»å‹å®‰å…¨
- æ¸…æ™°çš„ç›®å½•ç»“æ„ä½¿é¡¹ç›®æ›´æ˜“äºå¯¼èˆª

## åç«¯å¼€å‘æ ¸å¿ƒçŸ¥è¯†ç‚¹

### 1. REST vs GraphQL
- REST: å¤šç«¯ç‚¹ï¼Œå›ºå®šå“åº”ç»“æ„ï¼Œæ˜“äºç¼“å­˜
- GraphQL: å•ç«¯ç‚¹ï¼Œå®¢æˆ·ç«¯å®šä¹‰å“åº”ç»“æ„ï¼Œå‡å°‘è¿‡åº¦è·å–
- GraphQLå…è®¸å‰ç«¯ç²¾ç¡®æŒ‡å®šæ‰€éœ€æ•°æ®ï¼Œå‡å°‘ç½‘ç»œä¼ è¾“
- GraphQLè§£å†³äº†RESTä¸­çš„æ¬ è·å–å’Œè¿‡åº¦è·å–é—®é¢˜

### 2. èº«ä»½éªŒè¯å’Œæˆæƒ
- JWTæä¾›æ— çŠ¶æ€èº«ä»½éªŒè¯æœºåˆ¶
- å¯†ç åº”ä½¿ç”¨bcryptç­‰ç®—æ³•è¿›è¡Œå“ˆå¸Œå­˜å‚¨ï¼Œä¸å­˜å‚¨æ˜æ–‡
- æˆæƒæ£€æŸ¥ç¡®ä¿ç”¨æˆ·åªèƒ½è®¿é—®è‡ªå·±çš„èµ„æº
- èº«ä»½éªŒè¯é”™è¯¯ä¿¡æ¯åº”æ¨¡ç³ŠåŒ–ï¼Œä¸æ³„éœ²å…·ä½“é”™è¯¯åŸå› 

### 3. æ•°æ®æŒä¹…åŒ–
- ORM(å¦‚Prisma)ç®€åŒ–æ•°æ®åº“æ“ä½œå¹¶æä¾›ç±»å‹å®‰å…¨
- æ•°æ®è¿ç§»ç¡®ä¿æ•°æ®åº“æ¶æ„æ›´æ”¹å¯è¢«è¿½è¸ªå’Œç‰ˆæœ¬æ§åˆ¶
- å…³ç³»å‹æ•°æ®åº“(å¦‚PostgreSQL)æä¾›æ•°æ®å®Œæ•´æ€§å’Œäº‹åŠ¡æ”¯æŒ
- å®šä¹‰æ¸…æ™°çš„æ•°æ®æ¨¡å‹æ˜¯è®¾è®¡è‰¯å¥½åº”ç”¨çš„åŸºç¡€

### 4. æ€§èƒ½ä¼˜åŒ–
- ç¼“å­˜å‡å°‘æ•°æ®åº“æŸ¥è¯¢ï¼Œæé«˜å“åº”é€Ÿåº¦
- Redisé€‚åˆå­˜å‚¨é¢‘ç¹è®¿é—®çš„æ•°æ®
- ç¼“å­˜ç­–ç•¥éœ€è€ƒè™‘æ•°æ®æ›´æ–°æ—¶çš„ä¸€è‡´æ€§
- é€‚å½“çš„ç´¢å¼•è®¾è®¡å¯¹æ•°æ®åº“æ€§èƒ½è‡³å…³é‡è¦

### 5. é”™è¯¯å¤„ç†
- è‡ªå®šä¹‰é”™è¯¯ç±»æä¾›æ›´å…·æè¿°æ€§çš„é”™è¯¯
- åŒºåˆ†ç”¨æˆ·é”™è¯¯å’Œç³»ç»Ÿé”™è¯¯
- ç³»ç»Ÿé”™è¯¯åº”è®°å½•è¯¦ç»†ä¿¡æ¯ä½†å‘ç”¨æˆ·æä¾›æœ‰é™ä¿¡æ¯
- try/catchå—åº”å›´ç»•å¯èƒ½å¤±è´¥çš„æ“ä½œ

### 6. é¡¹ç›®ç»“æ„ä¸ç»„ç»‡
- æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡ä»£ç æé«˜å¯ç»´æŠ¤æ€§
- ä½¿ç”¨æœåŠ¡æ¨¡å¼å°è£…ç›¸å…³åŠŸèƒ½
- é¿å…é‡å¤ä»£ç ï¼Œæå–å…±ç”¨åŠŸèƒ½
- ä¾èµ–æ³¨å…¥æ¨¡å¼ä½¿ç»„ä»¶æ¾è€¦åˆæ˜“æµ‹è¯•

### 7. ç±»å‹å®‰å…¨
- TypeScriptæä¾›ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯
- æ¥å£å®šä¹‰æ˜ç¡®ç»„ä»¶é—´çš„æ•°æ®å¥‘çº¦
- æ³›å‹æé«˜ä»£ç é‡ç”¨æ€§å¹¶ä¿æŒç±»å‹å®‰å…¨
- ç±»å‹æ¨æ–­ä¸ç±»å‹æ–­è¨€å¹³è¡¡ä¾¿åˆ©æ€§å’Œå®‰å…¨æ€§

## æ‰©å±•å’Œä¸‹ä¸€æ­¥

å®ŒæˆåŸºç¡€è®¾ç½®åï¼Œä½ å¯ä»¥è€ƒè™‘ä»¥ä¸‹æ‰©å±•:

### åŠŸèƒ½æ‰©å±•
- æ·»åŠ ç¬”è®°æ ‡ç­¾å’Œåˆ†ç±»åŠŸèƒ½
- å®ç°ç¬”è®°åˆ†äº«å’Œåä½œ
- æ·»åŠ ç¬”è®°ç‰ˆæœ¬å†å²
- å®ç°å…¨æ–‡æœç´¢åŠŸèƒ½

### æŠ€æœ¯æ‰©å±•
- æ·»åŠ è‡ªåŠ¨åŒ–æµ‹è¯•(å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•)
- è®¾ç½®CI/CDæµæ°´çº¿
- æ·»åŠ ç›‘æ§å’Œå‘Šè­¦
- å®ç°è‡ªåŠ¨ç¼©æ”¾å’Œè´Ÿè½½å‡è¡¡

### å®‰å…¨å¢å¼º
- æ·»åŠ é€Ÿç‡é™åˆ¶é˜²æ­¢æš´åŠ›æ”»å‡»
- å®ç°CSRFå’ŒXSSé˜²æŠ¤
- æ·»åŠ æ•°æ®éªŒè¯å’Œå«ç”Ÿå¤„ç†
- è®¾ç½®å†…å®¹å®‰å…¨ç­–ç•¥(CSP)

### éƒ¨ç½²ä¼˜åŒ–
- Dockerå®¹å™¨åŒ–åº”ç”¨
- è®¾ç½®ç”Ÿäº§çº§æ—¥å¿—è®°å½•
- å®ç°æ•°æ®åº“å¤‡ä»½å’Œæ¢å¤ç­–ç•¥
- é…ç½®HTTPSå’Œé€‚å½“çš„å¤´éƒ¨å®‰å…¨è®¾ç½®

### å¼€å‘ä½“éªŒ
- æ·»åŠ APIæ–‡æ¡£ç”Ÿæˆ
- è®¾ç½®å¼€å‘ç¯å¢ƒè‡ªåŠ¨é‡è½½
- æ·»åŠ ä»£ç è´¨é‡å’Œæ ¼å¼æ£€æŸ¥
- å®ç°æ•°æ®åº“ç§å­å¡«å……ä¾¿äºå¼€å‘

é€šè¿‡æœ¬æŒ‡å—ï¼Œä½ å·²ç»æ„å»ºäº†ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ç¬”è®°åº”ç”¨åç«¯ï¼Œå®ƒä½¿ç”¨äº†ç°ä»£åŒ–çš„æŠ€æœ¯æ ˆå’Œæœ€ä½³å®è·µã€‚è¿™ä¸ªé¡¹ç›®ä¸ºä½ ä»å‰ç«¯å¼€å‘è€…è¿ˆå‘å…¨æ ˆå¼€å‘æä¾›äº†åšå®çš„åŸºç¡€ã€‚